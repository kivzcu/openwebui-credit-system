[{"id":"credit_management_charging_credits","user_id":"709ec92f-c42b-49d0-8763-cfb32116714d","name":"Credit management Charging credits","type":"filter","content":"\"\"\"\ntitle: Credit management Charging credits\nauthor: DDVVY\nversion: 1.0\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nimport httpx\n\n\nclass Filter:\n    class Valves(BaseModel):\n        show_status: bool = Field(\n            default=True, description=\"Zobrazit info o strÅ¾enÃ­ kreditÅ¯\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    def safe_token_count(self, text: str) -> int:\n        return max(1, len(text) // 4)\n\n    def extract_token_count(self, body, token_type: str) -> int:\n        \"\"\"\n        Tries to extract prompt_tokens or completion_tokens from various places.\n        Preferably from messages[-1][\"usage\"], then fallback to metadata, then estimate.\n        \"\"\"\n        try:\n            return int(body[\"messages\"][-1][\"usage\"].get(token_type, 0))\n        except Exception:\n            pass\n\n        try:\n            return int(body.get(\"metadata\", {}).get(\"metrics\", {}).get(token_type, 0))\n        except Exception:\n            pass\n\n        try:\n            return int(body.get(token_type, 0))\n        except Exception:\n            pass\n\n        return 0\n\n    async def outlet(\n        self, body, __user__=None, __event_emitter__=None, __event_call__=None\n    ):\n        user_id = __user__.get(\"id\")\n        model_name = body.get(\"model\", \"gpt-3.5-turbo\")\n\n        prompt_tokens = self.extract_token_count(body, \"prompt_tokens\")\n        completion_tokens = self.extract_token_count(body, \"completion_tokens\")\n\n        try:\n            async with httpx.AsyncClient() as client:\n                model_res = await client.get(\n                    \"http://host.docker.internal:8000/api/credits/models\"\n                )\n                user_res = await client.get(\n                    \"http://host.docker.internal:8000/api/credits/users\"\n                )\n                model_res.raise_for_status()\n                user_res.raise_for_status()\n                models = model_res.json()\n                users = user_res.json()\n        except Exception as e:\n            if self.valves.show_status and __event_emitter__:\n                await __event_emitter__(\n                    {\n                        \"type\": \"status\",\n                        \"data\": {\n                            \"description\": f\" Failed to load credit metadata: {str(e)}\",\n                            \"done\": True,\n                        },\n                    }\n                )\n            return body\n\n        model_data = next((m for m in models if m.get(\"id\") == model_name), None)\n        user_data = next((u for u in users if u.get(\"id\") == user_id), None)\n\n        if not model_data or not user_data:\n            if self.valves.show_status and __event_emitter__:\n                await __event_emitter__(\n                    {\n                        \"type\": \"status\",\n                        \"data\": {\n                            \"description\": \" Missing user or model data. Credit update skipped.\",\n                            \"done\": True,\n                        },\n                    }\n                )\n            return body\n\n        fixed_price = float(model_data.get(\"fixed_price\", 0))\n        variable_price = float(model_data.get(\"variable_price\", 0))\n        credits = float(user_data.get(\"credits\", 0))\n\n        cost = prompt_tokens * fixed_price + completion_tokens * variable_price\n        new_balance = max(0.0, credits - cost)\n\n        try:\n            async with httpx.AsyncClient() as client:\n                update_res = await client.post(\n                    \"http://host.docker.internal:8000/api/credits/update\",\n                    json={\n                        \"id\": user_id,\n                        \"credits\": new_balance,\n                        \"actor\": \"auto-system\",\n                    },\n                )\n                update_res.raise_for_status()\n        except Exception as e:\n            if self.valves.show_status and __event_emitter__:\n                await __event_emitter__(\n                    {\n                        \"type\": \"status\",\n                        \"data\": {\n                            \"description\": f\" Failed to deduct credits: {str(e)}\",\n                            \"done\": True,\n                        },\n                    }\n                )\n            return body\n\n        if self.valves.show_status and __event_emitter__:\n            await __event_emitter__(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"description\": (\n                            f\"ðŸ’³ Charged {cost:.3f} credits â€“ New balance: {new_balance:.3f}\"\n                        ),\n                        \"done\": True,\n                    },\n                }\n            )\n\n        return body\n","meta":{"description":"This feature strips credits on a query and shows the credit status.","manifest":{"title":"Credit management Charging credits","author":"DDVVY","version":"1.0"}},"is_active":true,"is_global":true,"updated_at":1747362537,"created_at":1747362516}]