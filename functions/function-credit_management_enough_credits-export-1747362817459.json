[{"id":"credit_management_enough_credits","user_id":"709ec92f-c42b-49d0-8763-cfb32116714d","name":"Credit management  enough credits","type":"filter","content":"\"\"\"\ntitle: Credit management  enough credits\nauthor: DDVVY\nversion: 1.0\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nimport httpx\n\n\n# If not available in your project, define your own exception:\nclass FilterException(Exception):\n    pass\n\n\nclass Filter:\n    \"\"\"\n    Filters prompts based on user's available credits. Blocks prompt execution if\n    the estimated cost exceeds available user credits. Fetches cost and user data\n    from a backend API.\n    \"\"\"\n\n    class Valves(BaseModel):\n        show_status: bool = Field(\n            default=True, description=\"Show credit status message to the user.\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    async def inlet(\n        self, body, __user__=None, __event_emitter__=None, __event_call__=None\n    ):\n        user_id = __user__.get(\"id\")\n        model_name = body.get(\"model\")\n        prompt_text = body[\"messages\"][-1][\"content\"]\n        prompt_tokens = body.get(\"prompt_tokens\") or max(len(prompt_text) // 4, 1)\n\n        try:\n            async with httpx.AsyncClient() as client:\n                users_res = await client.get(\n                    \"http://host.docker.internal:8000/api/credits/users\"\n                )\n                models_res = await client.get(\n                    \"http://host.docker.internal:8000/api/credits/models\"\n                )\n                users_res.raise_for_status()\n                models_res.raise_for_status()\n                users = users_res.json()\n                models = models_res.json()\n        except Exception as e:\n            body[\"messages\"][-1][\n                \"content\"\n            ] += f\"\\n\\nUnable to load credit data: {str(e)}\"\n            return body\n\n        user_data = next((u for u in users if u[\"id\"] == user_id), None)\n        if not user_data:\n            body[\"messages\"][-1][\"content\"] += \"\\n\\nUser data not found.\"\n            return body\n\n        model_data = next((m for m in models if m[\"id\"] == model_name), None)\n        if not model_data:\n            body[\"messages\"][-1][\"content\"] += \"\\n\\nModel not found in cost list.\"\n            return body\n\n        fixed_price = model_data.get(\"fixed_price\", 0)\n        cost = prompt_tokens * fixed_price\n        credits = user_data.get(\"credits\", 0)\n\n        if credits < cost:\n            if self.valves.show_status and __event_emitter__:\n                await __event_emitter__(\n                    {\n                        \"type\": \"status\",\n                        \"data\": {\n                            \"description\": f\"Insufficient credits â€“ prompt blocked.\",\n                            \"done\": True,\n                        },\n                    }\n                )\n\n            raise FilterException(\n                f\"You do not have enough credits: {credits} available, minimum {cost:.2f} required.\"\n            )\n\n        # Prompt is allowed, but no success message is emitted\n        return body\n","meta":{"description":"Checks if the user has at least one input prompt.","manifest":{"title":"Credit management  enough credits","author":"DDVVY","version":"1.0"}},"is_active":true,"is_global":true,"updated_at":1747361972,"created_at":1747361604}]